# GC (сборка мусора)

## Подсчет ссылок

Основным алгоритмом сборки мусора, используемым CPython, является подсчет ссылок. Идея, лежащая в основе этой концепции, заключается в том, что CPython подсчитывает количество разных мест, в которых есть ссылка на объект. Таким местом может быть другой объект, или глобальная (или статическая) Си переменная, или локальная переменная в какой-либо Си функции. Когда счетчик ссылок объекта становится равным нулю, объект освобождается. Если он содержит ссылки на другие объекты, их счетчики ссылок уменьшаются. Эти другие объекты могут быть освобождены в свою очередь, если это уменьшение приведет к тому, что их счетчик ссылок станет равным нулю, и так далее, вызывая каскадный эффект. Поле счетчика ссылок можно проверить с помощью функции `sys.getrefcount`
> Стоит обратить внимание, что значение, возвращаемое функцией `sys.getrefcount`, всегда больше на 1, поскольку функция также имеет ссылку на объект при вызове.

## Плюсы и минусы использования подсчета ссылок

- К плюсам можно отнести простоту реализации алгоритма
- К минусам можно отнести то, что подсчет ссылок занимает память. Чем больше ссылок, тем больше памяти они занимают

*Но самой главной проблемой подсчета ссылок являются циклы. Как обрабатывать циклические ссылки, где объект указывает сам на себя?*

## Циклические ссылки и поколенческая (generational) сборка мусора 

Решить проблему с циклическими ссылками призван второй механизм сборки мусора - поколенческий (***generational***). Основная идея, лежащая в основе этой концепции, заключается в предположении, что большинство объектов имеют очень короткий жизненный цикл и поэтому могут быть собраны вскоре после их создания. Это оказалось очень близким к реальности многих Python программ, поскольку многие временные объекты создаются и уничтожаются очень быстро. Чем старше объект, тем меньше вероятность того, что он станет недоступным.

Все контейнерные объекты разделяются на три поколения (далее G0, G1 и G2). Каждый новый объект начинает свой жизненный цикл в первом поколении (G0). Алгоритм подсчёта ссылок выполняется только над объектами конкретного поколения, и если объект выживает при сборке своего поколения, он будет перемещен в следующее поколение (G1), где он будет опрашиваться для сборки реже. Если тот же объект переживает еще один раунд GC в этом новом поколении (G1), он будет перемещен в последнее поколение (G2), где он будет опрашиваться для сборки реже всего.

Поколения *"собираются"*, когда количество содержащихся в них объектов достигает некоторого предопределенного порога, который уникален для каждого поколения и тем ниже, чем старше поколения. Эти пороги можно проверить с помощью функции `gc.get_threshold`:
```python
import gc
gc.get_threshold()
# output for 3.11 -> (700, 10, 10)
```

Объекты, содержащиеся в каждом конкретном поколении, можно получить с помощью функции `gc.get_objects(generation=NUM)`, а сборка мусора для каждого конкретного поколения может быть вызвана функцией `gc.collect(generation=NUM)`.

# Заключение

Сборка мусора реализована в **Python** двумя способами:
1. подсчет ссылок 
2. поколения. 

Когда счетчик ссылок на объект достигает 0, алгоритм сборки мусора с подсчетом ссылок немедленно очищает объект. Если есть цикл ссылок, счетчик не достигает нуля, то необходимо ждать, пока поколенческий алгоритм сборки мусора запустится и очистит объект.

----

**Ссылки**:

- [Python devguide](https://devguide.python.org/internals/garbage-collector/index.html)
- [GC исходный код](https://github.com/python/cpython/blob/3.10/Include/internal/pycore_gc.h)
